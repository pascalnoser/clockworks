---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/",
  out.width = "75%",
  fig.retina = 2
)
library(badger)
```

# clockworks

<!-- badges: start -->
`r badge_lifecycle("experimental")`
`r badge_devel("pascalnoser/clockworks", "blue")`
`r badge_code_size("pascalnoser/clockworks")`
<!-- badges: end -->

<img src="man/figures/clockworks_logo_v2.png" width="150" align="right"/>

> clockworks is an R package for streamlined rhythmicity detection in time-series data. It serves as a wrapper for several popular analysis tools, eliminating the need to wrangle data into tool-specific formats or learn each methodâ€™s quirks. With simple, consistent inputs, clockworks can automatically adjust parameters based on the input data and prevent the use of methods not suited to a given dataset. In just a few lines of code, the user can easily run multiple methods, compare results, and generate basic visualizations.

***

## Installation

You can install the development version of clockworks from GitHub with:

``` r
# install.packages("pak")
pak::pak("pascalnoser/clockworks")
```

## Usage

Detecting rhythmic features using your method of choice is very straightforward. In the example below, we will use a synthetic data set of two rhythmic and eight non-rhythmic genes. We will analyse them using [RAIN](https://www.bioconductor.org/packages/release/bioc/html/rain.html) as well as the [MetaCycle](https://github.com/gangwug/MetaCycle) implementation of [JTK_CYCLE](https://doi.org/10.1177/0748730410379711).

We start by loading the package and creating a `CircadianData` object using some synthetic example data. When using your own data, make sure that the formatting is the same as the `cw_data` and `cw_metadata` shown below:
```{r setup}
library(clockworks)

# Load example data and meta data
data("cw_data")
data("cw_metadata")

# The input data is a matrix or data frame with feature IDs as row names and
# sample IDs as column names
print(cw_data[1:5, 1:5])

# The meta data requires a column with sample IDs corresponding to the column
# names of the data and a column containing the time
print(head(cw_metadata))

# Create CircadianData object with default period of 24 hours
cd <- CircadianData(
  dataset = cw_data,
  metadata = cw_metadata,
  colname_sample = "Sample_ID",
  colname_time = "Time",
  colname_group = "Group"
)
```


This `CircadianData` object is a way to store all the relevant information in one container with standardised formatting. Printing the object returns an overview of what `clockworks` "sees". Note that e.g. the metadata column names have been renamed:
```{r cd_object_structure}
print(cd)
```


When creating a `CircadianData` object as we just did above, `clockworks` automatically runs a harmonic regression to fit a cosine wave to your data. You can visualise your data with the added cosine wave very easily. You can also add shading to distinguish between light and dark periods by defining the borders:
```{r plot_feature}
# Plot first feature
p <- plot_feature(
  cd = cd,
  feature = "Gene_01",
  background_cutoffs = c(12, 24, 36, 48)
)
print(p)
```


Since this is a ggplot2 object, it can be modified very easily.

Now that our `CircadianData` object is created, running the rhythmicity analysis is just one line of code. By changing the `method` argument you can easily run different methods on your data. The results are stored inside the `CircadianData` object so everything is in one place:
```{r analysis}
# Run analysis using RAIN
cd <- clockworks(cd, method = "RAIN")
# Run analysis using JTK_CYCLE
cd <- clockworks(cd, method = "JTK_CYCLE")
```


The `get_results()` function can be used to extract the results. By default, a formatted version of the results with consistent naming of columns across all methods will be returned:
```{r results}
# Extract formatted (standardised) results
res <- get_results(cd)
head(res$RAIN)
head(res$JTK_CYCLE)
```


The results of the harmonic regression are also included in this formatted output, allowing for a quick comparison of the estimated parameters to those of a simple cosine wave fit. The harmonic regression used is equivalent to the model $y = M + A \cos(\frac{2 \pi}{T}(t - \varphi))$ with $M$ the mesor, $A$ the amplitude, $t$ the time (e.g. in hours), and $T$ and $\phi$ the period and phase in the same units as $t$. The value of $\varphi$ corresponds to the time point of the first peak of the fitted wave.
